
fun就是匿名函数. 被称为匿名函数, 是因为它并没有名字. 我们来做点试验, 先定义一个fun, 然后把它赋给一个变量Z:

```erl
1> Z = fun(X) -> 2 * X end.
#Fun<erl_eval.6.56006484>
```

当定义一个fun时, Erlang shell会打印#Fun<...>, 这里的... 常常是一些奇怪的数字. 不过现在不用管它.

我们可以将一个参数应用到一个fun上, 对于fun来说, 这是我们唯一能做的事, 像这样: 

```erl
2> Z(2).
4
```

对这个fun来说, Z显然不是一个好名字, 叫做Double可能更好些, 这恰好表述了fun的功能:

```erl
3> Double = Z.
#Fun<erl_eval.6.10732646>
4> Double(4).
8
```

fun可以拥有任意数量的参数. 我们可以像下面一样, 编个函数来计算直角三角形的斜边:

```erl
5> Hypot = fun(X,Y) -> math:sqrt(X * X + Y * Y) end.
#Fun<erl_eval.12.115169474>
6> Hypot(3,4).
5.00000
```

如果调用参数的个数不正确, 会得到一个错误:

```erl
7> Hypot(3).
** exited: #Fun<erl_eval.12.115169474>
```

这个错误为何被称为birthday 一个函数可以接受的参数个数. badarity表明在Erlang中找不到由所调用的函数名及其给定的参数数量所表明的函数. 在这个例子中, 给出了函数Hypot, 它需要两个参数, 但我们只传了一个.

fun也可以有若干个不同的子句. 下面是在华氏气温和摄氏气温之间进行转换的函数:

```erl
8> TempConvert = fun({c,C}) -> {f, 32 + C * 9 / 5};
8>                  ({f,F}) -> {c, {F-32} * 5 / 9}
8>               end.
#Fun<erl_eval.6.56006484>
9> TempConvert({c,100}).
{f,212.000}
10> TempConvert({f,212}).
{c,100.000}
11> TempConvert({c,0}).
{f,32.0000}
```

说明: 第8行的表达式跨越了好几行, 在输入这个表达式时, 没输入一个新行shell都会重复打印 "8>", 这意味着这个表达式并未结束, shell还在等待后续的输入.

Erlang是一种函数式的编程语言, 也就是说, 除了极个别的情况外, fun既可以作为函数的参数, 也可以作为函数 (或者fun) 的结果.

这些能够返回fun或接受fun作为参数的函数, 都被称作高阶函数 (high-order function). 

## 以fun为参数的函数

list是标准库中的一个模块, 从中导出的很多函数都是以fun作为参数的. 其中, 最有用的是 lists.map(F,L). 这个函数将fun F应用到列表L的每一个元素上, 并返回一个新的列表.

```erl
12> L = [1,2,3,4].
[1,2,3,4]
12> lists:map(Double, L).
[2,4,6,8].
```

另一个常用的函数是lists.filter(P,L), 它返回一个新列表, 新列表由列表L中每一个能满足P(E)为true的元素组成.

让我们定义一个函数Even(X), 当X为奇数则返回true.

```erl
14> Even = fun(X) -> (X rem 2) =:= 0 end.
#Fun<erl_eval.6.56006484>
```

其中X rem 2是对X除2取余数, 而=:=是一个恒等测试符号. 现在我们可以测试一下Even, 然后用它作为map和filter的参数.

```erl
15> Even(8).
true
16> Even(7).
false
17> lists:map(Even, [1,2,3,4,5,6,8]).
[false,true,false,true,false,true,true]
18> lists.filter(Even, [1,2,3,4,5,6,8]).
[2,4,6,8]
```

我们将像map和filter这样在一个函数调用中处理整个列表的操作称为list-at-a-time操作.

list-at-a-time操作能让程序变得简洁易懂, 有了它, 我们就可以把处理整个列表的程序看作是一个的抽象步骤. 这就是我们的程序能变得更为精炼的原因. 否则, 我们必须将处理列表元素的操作分解为一系列独立的步骤.

## 返回fun的函数

fun不仅可以用作函数的参数 (比如map和filter), 而且其他函数也可以将fun当作返回值. 下面是一个例子, 假设有一个名为fruit的列表:

```erl
1> Fruit = [apple,pear,orange].
[apple,pear,orange]
2> MakeTest = fun(L) -> (fun(X) -> lists:member(X,L) end) end.
#Fun<erl_eval.6.56006484>
3> IsFruit = MakeTest(Fruit).
#Fun<erl_eval.6.56006484>
```

如果X是列表L的成员, 那么函数lists:member(X,L) 返回true, 反之则返回false. 现在我们已经编写了一个测试函数, 可以进行一些测试.

```erl
4> IsFruit(pear).
true
5> IsFruit(apple).
true
6> IsFruit(dog).
false
```

同样, 我们还能将其用作lists:filter/2的参数:

```erl
7> lists.filter(IsFruit, [dog,orange,cat,apple,bear]).
[orange,apple]
```

返回fun的fun, 这个语法多少让人迷惑, 下面花一点时间想想, 一个返回"正常"值得fun一般是这样的:

```erl
1> Double = fun(X) -> (2 * X) end.
#Fun<erl_eval.6.56006484>
2> Double(5).
10
```

括号之中的代码 (更明确地说, 也就是2 * X)很明显就是函数的返回值. 现在我们试着把这个fun放进括号之中. 请记住, 括号之中的东西就是返回值:

```erl
3> Mult = fun(Times) -> ( fun(X) -> X * Times end ) end.
#Fun<erl_eval.6.56006484>
```







