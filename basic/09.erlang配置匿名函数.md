
fun就是匿名函数. 被称为匿名函数, 是因为它并没有名字. 我们来做点试验, 先定义一个fun, 然后把它赋给一个变量Z:

```erl
1> Z = fun(X) -> 2 * X end.
#Fun<erl_eval.6.56006484>
```

当定义一个fun时, Erlang shell会打印#Fun<...>, 这里的... 常常是一些奇怪的数字. 不过现在不用管它.

我们可以将一个参数应用到一个fun上, 对于fun来说, 这是我们唯一能做的事, 像这样: 

```erl
2> Z(2).
4
```

对这个fun来说, Z显然不是一个好名字, 叫做Double可能更好些, 这恰好表述了fun的功能:

```erl
3> Double = Z.
#Fun<erl_eval.6.10732646>
4> Double(4).
8
```

fun可以拥有任意数量的参数. 我们可以像下面一样, 编个函数来计算直角三角形的斜边:

```erl
5> Hypot = fun(X,Y) -> math:sqrt(X * X + Y * Y) end.
#Fun<erl_eval.12.115169474>
6> Hypot(3,4).
5.00000
```

如果调用参数的个数不正确, 会得到一个错误:

```erl
7> Hypot(3).
** exited: #Fun<erl_eval.12.115169474>
```

这个错误为何被称为birthday 一个函数可以接受的参数个数. badarity表明在Erlang中找不到由所调用的函数名及其给定的参数数量所表明的函数. 在这个例子中, 给出了函数Hypot, 它需要两个参数, 但我们只传了一个.

fun也可以有若干个不同的子句. 下面是在华氏气温和摄氏气温之间进行转换的函数:

```erl
8> TempConvert = fun({c,C}) -> {f, 32 + C * 9 / 5};
8>                  ({f,F}) -> {c, {F-32} * 5 / 9}
8>               end.
#Fun<erl_eval.6.56006484>
9> TempConvert({c,100}).
{f,212.000}
10> TempConvert({f,212}).
{c,100.000}
11> TempConvert({c,0}).
{f,32.0000}
```

说明: 第8行的表达式跨越了好几行, 在输入这个表达式时, 没输入一个新行shell都会重复打印 "8>", 这意味着这个表达式并未结束, shell还在等待后续的输入.

Erlang是一种函数式的编程语言, 也就是说, 除了极个别的情况外, fun既可以作为函数的参数, 也可以作为函数 (或者fun) 的结果.

这些能够返回fun或接受fun作为参数的函数, 都被称作高阶函数 (high-order function). 

