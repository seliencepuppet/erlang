
接下来会用Erlang进行简单的顺序型程序编写, 了解它们让其发挥更多的作用.

## 模块

<br/>

模块是Erlang中代码的基本单元, 我们编写的所有函数都存于模块之中. 模块文件通常存放在以 .erl 为扩展名的文件中.

要运行一个模块, 首先要编译它, 编译成功之后的模块文件其扩展名是 .beam 

在我们动手编写第一个模块之前, 先来回顾一下有关模式匹配的只是. 下面的内容中, 我们会创建两个数据结构, 分别用来表示矩形和圆. 之后再来解析这些数据结构, 从矩形中取边长, 从园中取半径, 下面是实现方式:

```erl
1> Rectangle = {rectangle, 10, 5}.
{rectangle, 10, 5}
2> Circle = {circle, 2.4}.
{circle, 2.40000}
3> {rectangle, Width, Ht} = Rectangle.
{rectangle, 10, 5}
4> Width.
10
5> Ht.
5
6> {circle, R} = Circle.
{circle, 2.40000}
7> R.
2.40000
```

第1行和第2行分别创建了矩形和圆. 第3行和第6行用模式匹配分别提取了矩形和圆中的字段. 在第4行, 第5行和第7行, 打印这些通过模式匹配获得的值. 运行到第7行之后, shell中的变量绑定是这样的: {Width -> 10, Ht -> 5, R -> 2.4}.

将模式匹配从shell挪到函数中只需稍加改变. 首先, 我们来创建一个名为 area的函数, 用它来计算矩形和圆的面积. 我们把这个函数放在gemoetry模块中, 并把这个模块存到 geometry.erl文件中. 下面就是这个模块的完整内容.

```geometry.erl
-module(geometry).
-export([area/1]).
area({rectangle, Width, Ht}) -> Width * Ht;
area({circle, R})            -> 3.14159 * R * R.
```

先不理会 -module和-export声明 (我们稍后会再讨论它们), 现在我们只关注area函数. 

area函数由两个子句构成, 子句间以分号分割, 最后一条子句的后面以句点作为结束符. 每一个字句都有一个函数头和一个函数体, 函数头由函数名和随后的以括号括起来的模式组成, 函数体则由一系列表达式组成, 如果函数头中的模式与调用参数匹配成功的话, 其对应的表达式就会进行计算. 模式将按照它们出现在函数定义中的先后顺序进行匹配.

注意, 形如 {rectangle, Width, Ht} 的模式是area函数定义的一部分. 每个模式都明确地与一个字句相对应. 下面看看area函数的第一个子句.

```erl
area({rectangle, Width, Ht}) -> Width * Ht;
```

这是一条计算矩形面积的规则. 当我们的调用时geometry: area({rectangle, 10, 5})时, 最前面那个模式被匹配, 绑定变量{Width -> 10, Ht -> 5}. 匹配完之后, ->号之后的代码回被执行. 这里是Width * Ht, 即 10 * 5, 结果为50.

现在开始编译该函数:

```erl
1> c(geometry).
{ok,geometry}
2> geometry:area({rectangle, 10, 5}).
50
3> geometry:area({circle, 1.4}).
6.15752
```

上面的演示的意义何在? 在第1行输入命令c(geometry), 编译geometry.erl文件中的源代码. 编译器返回{ok,geometry}, 意味着编译成功, 模块geometry已经被编译并加载, 第2行和第3行是在geometry模块之中调用定义的函数. 注意, 如何同时使用模块名和函数名以精确定位希望调用的函数.

## 



