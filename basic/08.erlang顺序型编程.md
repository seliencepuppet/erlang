
接下来会用Erlang进行简单的顺序型程序编写, 了解它们让其发挥更多的作用.

## 模块

<br/>

模块是Erlang中代码的基本单元, 我们编写的所有函数都存于模块之中. 模块文件通常存放在以 .erl 为扩展名的文件中.

要运行一个模块, 首先要编译它, 编译成功之后的模块文件其扩展名是 .beam 

在我们动手编写第一个模块之前, 先来回顾一下有关模式匹配的只是. 下面的内容中, 我们会创建两个数据结构, 分别用来表示矩形和圆. 之后再来解析这些数据结构, 从矩形中取边长, 从园中取半径, 下面是实现方式:

```erl
1> Rectangle = {rectangle, 10, 5}.
{rectangle, 10, 5}
2> Circle = {circle, 2.4}.
{circle, 2.40000}
3> {rectangle, Width, Ht} = Rectangle.
{rectangle, 10, 5}
4> Width.
10
5> Ht.
5
6> {circle, R} = Circle.
{circle, 2.40000}
7> R.
2.40000
```

第1行和第2行分别创建了矩形和圆. 第3行和第6行用模式匹配分别提取了矩形和圆中的字段. 在第4行, 第5行和第7行, 打印这些通过模式匹配获得的值. 运行到第7行之后, shell中的变量绑定是这样的: {Width -> 10, Ht -> 5, R -> 2.4}.

将模式匹配从shell挪到函数中只需稍加改变. 首先, 我们来创建一个名为 area的函数, 用它来计算矩形和圆的面积. 我们把这个函数放在gemoetry模块中, 并把这个模块存到 geometry.erl文件中. 下面就是这个模块的完整内容.

```geometry.erl
-module(geometry).
-export([area/1]).
area({rectangle, Width, Ht}) -> Width * Ht;
area({circle, R})            -> 3.14159 * R * R.
```

先不理会 -module和-export声明 (我们稍后会再讨论它们), 现在我们只关注area函数. 

area函数由两个子句构成, 子句间以分号分割, 最后一条子句的后面以句点作为结束符. 每一个字句都有一个函数头和一个函数体, 函数头由函数名和随后的以括号括起来的模式组成, 函数体则由一系列表达式组成, 如果函数头中的模式与调用参数匹配成功的话, 其对应的表达式就会进行计算. 模式将按照它们出现在函数定义中的先后顺序进行匹配.

注意, 形如 {rectangle, Width, Ht} 的模式是area函数定义的一部分. 每个模式都明确地与一个字句相对应. 下面看看area函数的第一个子句.

```erl
area({rectangle, Width, Ht}) -> Width * Ht;
```

这是一条计算矩形面积的规则. 当我们的调用时geometry: area({rectangle, 10, 5})时, 最前面那个模式被匹配, 绑定变量{Width -> 10, Ht -> 5}. 匹配完之后, ->号之后的代码回被执行. 这里是Width * Ht, 即 10 * 5, 结果为50.

现在开始编译该函数:

```erl
1> c(geometry).
{ok,geometry}
2> geometry:area({rectangle, 10, 5}).
50
3> geometry:area({circle, 1.4}).
6.15752
```

上面的演示的意义何在? 在第1行输入命令c(geometry), 编译geometry.erl文件中的源代码. 编译器返回{ok,geometry}, 意味着编译成功, 模块geometry已经被编译并加载, 第2行和第3行是在geometry模块之中调用定义的函数. 注意, 如何同时使用模块名和函数名以精确定位希望调用的函数.

## 扩展这个程序

假如现在想要扩展这个程序, 加入对正方形这种几何对象的支持, 可以这么做:

```erl
area({rectangle, Width, Ht}) -> Width * Ht;
area({circle, R})            -> 3.14159 * R * R;
area({square, X})            -> X * X.
```

或者这么写

```erl
area({rectangle, Width, Ht}) -> Width * Ht;
area({square, X})            -> X * X;
area({circle, R})            -> 3.14159 * R * R.
```

在这个例子中, 子句的顺序并不重要, 无论这些子句的顺序如何, 对程序来说, 运行的效果都是一样的. 这是因为 (这个例子中) 各子句的模式彼此互不相干. 这使编写和扩展程序变得很简单, 只须添加新的模式就行了. 不过, 通常来说子句的顺序还是有点关系的, 因为进入一个函数的时候, 调用是按照模式在文件中的顺序依次进行匹配的.

继续深入之前, 小结一下, 对于area函数的编写方式, 我们应该注意以下两点.

1) area函数由若干个不同的子句构成. 当调用这个函数时, 对其调用参数的匹配过程从第一个子句开始依次向下进行.
2) 函数不能处理模式匹配失败的情形, 此时程序会失败并抛出一个运行时错误. 这一点是故意为之.

很多变成语言, 比如C语言, 每个函数只有一个入口点. 如果用C语言来些这个程序的话, 代码很可能会是这个样子:

```c
enum ShapeType { Rectangle, Circle, Square };

struct Shape {
    enum ShapeType kind;
    union {
        struct { int width, height; } rectangleData;
        struct { int radius; }        circleData;
        struct { int side; }          squareData;
    } shapeData;
};

double area(struct Shape* s){
    if(s->kind == Rectangle){
        int width, ht;
        width = s-shapeData.rectangleData.width;
        ht = s->shapeData.rectangleData.ht;
        return width * ht;
    }else if(s->kind == Circle){
        ...
    }
}
```

C代码向我们原原本本地展示了参数和函数进行模式匹配的过程. 在C语言中, 程序员必须自己编写模式匹配代码, 并保证他们正确无误.

在Erlang中, 做相同的事, 只需要编写模式, Erlang编译器会自动生成优化的模式匹配代码, 帮程序找到正确的入口点.

```java
abstract class Shape {
    abstract double area();
}

class Circle extends Shape {
    final double radius;
    Circle(double radius){
        this.radius = radius;
    }
    
    double area(){
        return Math.PI = radius * radius;
    }
}

class Rectangle extends Shape {
    final double ht;
    final double width;
    
    Rectangle(double width, double height){
        this.ht = height;
        this.width = width;
    }
    
    double area(){
        return width * ht;
    }
}

class Square extends Shape {
    final double side;
    
    Square(double side){
        this.side = side;
    }
    
    double area(){
        return side * side;
    }
}
```









