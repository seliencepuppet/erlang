
## 变量

怎样才能把一个命令的结果保存起来, 以供后面使用呢? 这就是变量的职责所在. 下面是一个例子:

```erl
1> X = 123456789.
123456789
```

这是什么意思呢? 首先, 我们向变量X赋了一个值, 然后shell打印出了变量的值.

#### 说明   所有的变量都必须以大写字母开头.

如果要查看一个变量的值, 那么只需要输入变量的名字即可:

```erl
2> X.
123456789
```

现在X有了值, 你可以这样使用它:

```erl
3> X * X * X * X.
232305722798259244150093798251441
```

然而, 要是给变量X赋上一个另外的值, 那么系统会无情地抛给你一个错误消息.

```erl
4> X = 1234.
** exception error: no match of right hand side value 1234
```

首先, X不是一个变量, 至少不是在Java或者C当中碰到的那种变量.

其次, =不是一个赋值操作符.

对于erlang新手来说, 这可能是最让人犯晕的地方之一, 为此, 很有必要来深入地探讨一下这个问题.


## 变量不变

Erlang的变量是单一赋值变量. 恰如其名, 单一赋值变量的值只能一次性地给定. 一个变量一旦被赋了值, 要想再次改变它, 就会得到一个错误(实际上, 我们刚才得到的是一个匹配失败的错误). 一个变量如果含有一个赋予的值, 就称为绑定变量, 否则, 则被称作自由变量. 

开始所有的变量都是自由的.

当Erlang遇到语句X=1234时, 它就将值1234绑定到X. 而在被绑定之前, X可以接受任何值, 它就像是一个需要被填满的空洞. 但是, 一旦它得到了某个值, 那么它就永远保持这个值.

到了这里, 可能会有些奇怪, 既然如此, 使用变量这个术语的意义又在哪里, 主要有两个原因:
1) 它们的确也是变量, 只不过它们的值只能改变一次 (也就是, 它们从自由变量变成了绑定变量).
2) 它们看上去与传统编程语言中的变量很相似, 因此, 当遇到一行这样的代码:

```erl
X=...
```

我们心里就会开始想, "嗯, 这个我知道, X是一个变量, =是一个赋值操作符". 实际上, 我们的这些想法也没什么大错, X近似于一个变量, =也近似于一个赋值操作符. 说明, 出现在Erlang代码之中的省略号 (...) 意味着 "此处省略掉了一些代码".

最后, 定义一个变量的词法单元就是这个变量的作用域. 因此, 如果在一个函数语句范围内使用X, 那么X的值就不能 "跳出" 语句之外. 在同一个函数的不同子句中, 彼此之间也不存在全局或者共享的私有变量. 如果X出现在许多个不同的函数当中, 那么这些X的值也都是各自独立的.

示例如下:

```erl
[root@zhangyz ~]# erl
Erlang R16B02 (erts-5.10.3) [source] [64-bit] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V5.10.3  (abort with ^G)
1> X = 1234.
1234
2> X.
1234 
3> X = 123.
** exception error: no match of right hand side value 123
4> X.
1234
```

## 模式匹配

在大多数的编程语言中, =都表示赋值语句. 然而, 在Erlang中, =表示一个模式匹配操作. Lhs = Rhs 实际上是这样一个过程, 对右端求值



## 单一赋值为何有益于编写质量更高的代码

Erlang里面的变量仅是对值的一个引用, 就具体实现而言, 一个绑定变量就是一个指针, 这个指针指向存放那个值的存储区. 而那个值是无法改变的.

不能改变一个变量的值是极为重要的事实, 因为这与 C, Java 这样的命令式语言中的变量是不同的.

现在来看看, 如果允许改变变量, 又会发生什么情况. 先定义一个变量 X:

```erl
1> X = 23.
23
```

现在用X进行计算:

```erl
2> Y = 4 * X + 3.
95
```

假定可以修改X的值:

```erl
3> X = 19.
** exception error: no match of right hand side value 3
```

幸运的是, Erlang不允许这么做, shell命令行会报错, 也就是说已经给X变量赋值成为23了, 它就不能是19

但是, 加入可以这么做, 那么Y的当前值就是不正确的, 就不能把语句2看作一个等式, 此外, 如果在程序中不同的地方允许X多次改变自己的值, 那么一旦某些部分出错了, 我们会很难确定具体哪个X值引起的, 也就是说, 会很难精确找到出错语句.

在代码错误的排查中相当常见的一种错误是, 变量被赋了一个错误的值. 在这种情况下, 你需要找出程序从哪儿获得的错误值. 如果变量在程序的不同地方多次修改了值. 那么要找出哪些修改时错误的是非常困难的.

在Erlang中就不存在这个问题, 变量赋值一次之后永不再变. 一旦发现某个变量出错, 我们就能立刻确定程序之中绑定这个变量的代码, 它就是错误产生之处.






