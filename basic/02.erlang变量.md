
## 变量

怎样才能把一个命令的结果保存起来, 以供后面使用呢? 这就是变量的职责所在. 下面是一个例子:

```erl
1> X = 123456789.
123456789
```

这是什么意思呢? 首先, 我们向变量X赋了一个值, 然后shell打印出了变量的值.

#### 说明   所有的变量都必须以大写字母开头.

如果要查看一个变量的值, 那么只需要输入变量的名字即可:

```erl
2> X.
123456789
```

现在X有了值, 你可以这样使用它:

```erl
3> X*X*X*X.
232305722798259244150093798251441
```

然而, 要是给变量X赋上一个另外的值, 那么系统会无情地抛给你一个错误消息.

```erl
4> X = 1234.
** exception error: no match of right hand side value 1234
```

首先, X不是一个变量, 至少不是在Java或者C当中碰到的那种变量.

其次, =不是一个赋值操作符.

对于erlang新手来说, 这可能是最让人犯晕的地方之一, 为此, 很有必要来深入地探讨一下这个问题.


## 变量不变

Erlang的变量是单一赋值变量. 恰如其名, 单一赋值变量的值只能一次性地给定. 一个变量一旦被赋了值, 要想再次改变它, 就会得到一个错误(实际上, 我们刚才得到的是一个匹配失败的错误). 一个变量如果含有一个赋予的值, 就称为绑定变量, 否则, 则被称作自由变量. 

开始所有的变量都是自由的.

当Erlang遇到语句X=1234时, 它就将值1234绑定到X. 而在被绑定之前, X可以接受任何值, 它就像是一个需要被填满的空洞. 但是, 一旦它得到了某个值, 那么它就永远保持这个值.

到了这里, 可能会有些奇怪, 既然如此, 使用变量这个术语的意义又在哪里, 主要有两个原因:
1) 它们的确也是变量, 只不过它们的值只能改变一次 (也就是, 它们从自由变量变成了绑定变量).
2) 它们看上去与传统编程语言中的变量很相似, 因此, 当遇到一行这样的代码:

```erl
X=...
```

我们心里就会开始想, "嗯, 这个我知道, X是一个变量, =是一个赋值操作符". 实际上, 我们的这些想法也没什么大错, X近似于一个变量, =也近似于一个赋值操作符. 说明, 出现在Erlang代码之中的省略号 (...) 意味着 "此处省略掉了一些代码".

最后, 定义一个变量的词法单元就是这个变量的作用域. 因此, 如果在一个函数语句范围内使用X, 那么X的值就不能 "跳出" 语句之外. 在同一个函数的不同子句中, 彼此之间也不存在全局或者共享的私有变量. 如果X出现在许多个不同的函数当中, 那么这些X的值也都是各自独立的.

## 模式匹配

