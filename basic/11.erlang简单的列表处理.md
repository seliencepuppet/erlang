
用sum编写一个功能, 计算列表内所有元素之和.

```mylists.erl
sum([H|T]) -> H + sum(T);
sum([])    -> 0.
```

注意, sum中两个子句的顺序是无关紧要的. 因为第一个子句匹配一个非空列表, 第二个子句匹配空列表, 这两种情况是不会互相干扰的. 可以这样测试:

```erl
1> c(mylists). %% <-- Last time I do this
{ok,mylists}
2> L = [1,3,10].
[1,3,10]
3> mylists:sum(L).
14
```

第一行编译了mylists模块. 之后, sum函数的内部工作机制极易理解

```work
(1) sum([1,3,10])
(2) sum([1,3,10]) = 1 + sum([3,10])
(3) = 1 + 3 + sum([10])
(4) = 1 + 3 + 10 + sum([])
(5) = 1 + 3 + 10 + 0
(6) = 14
```


如果使用map, 会产生什么效果呢?

```mylists.erl
map(_, []) -> [];
map(F, [H|T]) -> [F(H)|map(F, T)].
```

第一个子句表示该对一个空列表做什么处理. 把任何函数映射到一个空列表 (它没有任何元素) 上只能产生一个空列表.

第二个子句是一个处理非空列表的规则, 它的头是H, 尾是T. 同样非常简单, 只是创建一个新列表, 其头是F(H), 尾是map(F,T) .

下面用两个函数来运行map, 一个是对列表中的元素乘2, 一个是对列表中的元素求平方.

```erl
1> L = [1,2,3,4,5].
[1,2,3,4,5].
2> mylists.map(fun(X) -> 2 * X end, L).
[2,3,4,8,10]
3> mylists.map(fun(X) -> X * X end, L).
[1,4,9,16,25]
```


