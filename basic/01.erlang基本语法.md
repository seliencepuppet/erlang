
启动shell

shell是一个交互工具, 我们常用它来完成与erlang的互动. 启动shell之后, 我们可以输入表达式, 然后shell就会返回这些表达式的值.

如果已经安装好了erlang, 那么erlang shell -- erl也就同时安装好了. 要运行它, 请开启一个传统的操作系统命令行界面 (Windows上是cmd, 而在类Unix的系统上则是bash这样的shell程序)

```erl
[root@zhangyz ~]# erl
Erlang/OTP 20 [erts-9.1.2] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V9.1.2  (abort with ^G)
1> % I'm going to enter the shell ..
1> 20 + 30.
50
2> 
```

看看刚才的操作
1) 这是在Unix命令下启动Erlang Shell. shell返回了一个提示, 告诉你正在运行的是哪个版本的Erlang
2) shell显示了提示符1>, 然后我们输入了一串注释, 百分号 (%) 表示一个注释的开始. 从百分号开始到这行结束的所有文本都被看作是注释, 它会被shell和Erlang编译器忽略.
3) 由于我们并没有输入一个完整的命令, 所以shell重复显示1> . 在此时, 我们输入表达式 20+30, 而后紧跟一个句点和一个回车 (初学者往往会忘记输入句点. 没有句点, Erlang就认为我们还没有输完整个表达式, 我们也不会看到的结果).
4) shell 对表达式求值, 然后打印结果 (这里的结果是50)
5) shell 打印出另外一个提示符, 这次显示命令数为2 (因为命令数会随着每次新命令的输入而增加).

有没有在你的系统上试着运行过shell? 随着经验的计累, 你会发现shell其实是一个非常强大的工具. 之前录入shell的命令可以用Ctrl+P和Ctrl+N来找回, 也能用类似Emacs的编辑命令来编辑它们. 更妙的是, 当开始编写分布式的程序时, 一个集群内会有许多正运行着Erlang系统的节点, 你将发现可以将shell随意地附着到它们中的任何一个上.

### 警告

本书之中, 也不是所有的东西都能输入shell. 特别要注意的是, 你不能往shell里面输入Erlang文件当中的代码.  .erl文件中的句法形式不是表达式, 他不能被shell所接受. shell仅仅能够对Erlang表达式求值, 除此之外的其他事情, 它都做不了, 另外需要特别注意的是, 你不能在shell中输入模块注释, 这些注解以连字号开始 (比如 - module, --export 等)

### 简单的整数运算

先计算几个算数表达式:

```erl
1> 2 + 3 * 4
14
2> (2 + 3) * 4
20
```

## 要点

你会注意到这段对话以命令行数1开始 (也就是说shell打印了1>). 这表明我们开启了一个新的shell, 如若不然, 则意味着shell继续上一个样例的会话. 为了正确地再现本书中的样例, 你必须在看到对话从 1> 开始时重新启动shell, 反之则不必.



