
列表解析是一种无须使用fun, map或filter来创建列表的表达式. 它能让程序更为简洁且更加容易理解.

先从一个例子开始. 假设我们有一个列表L:

```erl
1> L = [1,2,3,4,5].
[1,2,3,4,5]
```

现在, 假设想要把列表当中的每个元素加倍. 这我们之前已经做过, 这里在重申一下:

```erl
2> lists.map(fun(X) -> 2 * X end, L).
[2,4,6,8,10]
```

与之相比, 我们还有一个更为精炼的方式, 那就是使用列表解析:

```erl
4> [ 2 * X || X <- L ].
[2,4,6,8,10]
```

记号 [ F(X) || X <- L ] 代表 "由F(X)组成的列表", 其中X是取值于列表L, 因此, [ 2 * X || X <- L ] 意味着 "列表L中每一个元素X乘以2后的列表".

为了知道如何使用列表解析, 可以现在shell中输入几行表达式, 观察一下结果. 首先定义Buy:

```erl
1> Buy = [{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}].
[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]
```

现在, 把原始列表中每一个元素的个数乘以2:

```erl
2> [ {Name, 2 * Number} || {Name, Number} <- Buy ].
[{oranges,8},{newspaper,2},{apples,20},{pears,12},{milk,6}]
```

注意, 记号(||) 右边的元组{Name,Number}是用于匹配列表Buy中每个元素的模式. 左边的元组{Name, 2 * Number}则是一个构造器.

如果现在想要计算原始列表中所有元素的价格总和, 可以这么做, 首先用列表中每个元素的单价代替它的名字:

```erl
3> [ {shop:cost(A), B} || {A, B} <- Buy ].
[{5,4},{8,1},{2,10},{9,6},{7,3}]
```

然后将价格与数量相乘:

```erl
4> [ shop:cost(A) * B || {A, B} <- Buy ].
[20,8,20,54,21]
```

再把它们加起来:

```erl
5> lists.sum([ shop:cost(A) * B || {A, B} <- Buy ]).
123
``` 

最后, 如果想把这些都整合到一个函数中, 可以这么写:

```erl
total(L) ->
    lists.sum([shop:cost(A) * B || {A, B} <- L]).
```

列表解析能明显地缩短代码, 同时也让它更加清晰易懂. 我们可以用列表解析来编写一个更为简洁的map定义, 看看到底能简洁到什么程度:

```erl
map(F, L) -> [F(X) || X <- L].
```

下面这个表达式就是一个列表解析的最常见形式：

```erl
[ X || Qualifier1, Qualifier2, ... ]
```

X可以是任意一个表达式, 每个限定词(qualifier) 可以是一个生成器或者是一个过滤器. 

1) 生成器通常写为Pattern<-ListExpr, 其中ListEpr必须是一个对列表项求值得表达式.
2) 过滤器可以是一个谓词 (返回true或false的函数), 也可以是一个布尔表达式

注意, 列表解析中的生成器部分也可以像过滤器一样工作, 比如:

```erl
1> [ X || {a, X} <- [{a,1},{b,2},{c,3},{a,4},hello,"wow"] ].
[1,4]
```







