
列表解析是一种无须使用fun, map或filter来创建列表的表达式. 它能让程序更为简洁且更加容易理解.

先从一个例子开始. 假设我们有一个列表L:

```erl
1> L = [1,2,3,4,5].
[1,2,3,4,5]
```

现在, 假设想要把列表当中的每个元素加倍. 这我们之前已经做过, 这里在重申一下:

```erl
2> lists.map(fun(X) -> 2 * X end, L).
[2,4,6,8,10]
```

与之相比, 我们还有一个更为精炼的方式, 那就是使用列表解析:

```erl
4> [ 2 * X || X <- L ].
[2,4,6,8,10]
```

记号 [ F(X) || X <- L ] 代表 "由F(X)组成的列表", 其中X是取值于列表L, 因此, [ 2 * X || X <- L ] 意味着 "列表L中每一个元素X乘以2后的列表".

为了知道如何使用列表解析, 可以现在shell中输入几行表达式, 观察一下结果. 首先定义Buy:

```erl
1> Buy = [{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}].
[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]
```

现在, 把原始列表中每一个元素的个数乘以2:

```erl
2> [ {Name, 2 * Number} || {Name, Number} <- Buy ].
[{oranges,8},{newspaper,2},{apples,20},{pears,12},{milk,6}]
```

注意, 记号(||) 右边的元组{Name,Number}是用于匹配列表Buy中每个元素的模式. 左边的元组{Name, 2 * Number}则是一个构造器.

如果现在想要计算原始列表中所有元素的价格总和, 可以这么做, 首先用列表中每个元素的单价代替它的名字:

```erl
3> [ {shop:cost(A), B} || {A, B} <- Buy ].
[{5,4},{8,1},{2,10},{9,6},{7,3}]
```

然后将价格与数量相乘:

```erl
4> [ shop:cost(A) * B || {A, B} <- Buy ].
[20,8,20,54,21]
```

再把它们加起来:

```erl
5> lists.sum([ shop:cost(A) * B || {A, B} <- Buy ]).
123
``` 



