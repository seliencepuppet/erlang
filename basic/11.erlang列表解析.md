
列表解析是一种无须使用fun, map或filter来创建列表的表达式. 它能让程序更为简洁且更加容易理解.

先从一个例子开始. 假设我们有一个列表L:

```erl
1> L = [1,2,3,4,5].
[1,2,3,4,5]
```

现在, 假设想要把列表当中的每个元素加倍. 这我们之前已经做过, 这里在重申一下:

```erl
2> lists.map(fun(X) -> 2 * X end, L).
[2,4,6,8,10]
```

与之相比, 我们还有一个更为精炼的方式, 那就是使用列表解析:

```erl
4> [ 2 * X || X <- L ].
[2,4,6,8,10]
```

记号 [ F(X) || X <- L ] 代表 "由F(X)组成的列表", 其中X是取值于列表L, 因此, [ 2 * X || X <- L ] 意味着 "列表L中每一个元素X乘以2后的列表".

为了知道如何使用列表解析, 可以现在shell中输入几行表达式, 观察一下结果. 首先定义Buy:

```erl
1> Buy = [{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}].
[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]
```

现在, 把原始列表中每一个元素的个数乘以2:

```erl
2> [ {Name, 2 * Number} || {Name, Number} <- Buy ].
[{oranges,8},{newspaper,2},{apples,20},{pears,12},{milk,6}]
```

